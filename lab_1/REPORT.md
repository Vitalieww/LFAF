# Grammar and Finite Automaton Implementation

### Course: Formal Languages & Finite Automata
### Author: Vitalie Vasilean FAF-241

## Theory

A **formal grammar** is a mathematical system that defines a formal language through a set of production rules. It consists of four components: a set of non-terminal symbols (VN), a set of terminal symbols (VT), a set of production rules (P), and a start symbol (S).

A **finite automaton** (FA) is a computational model that recognizes patterns in strings. It consists of a finite set of states, an alphabet of input symbols, a transition function, an initial state, and a set of final (accepting) states. The automaton processes input symbols one by one, transitioning between states, and accepts a string if it ends in a final state.

Regular grammars (Type-3 in Chomsky hierarchy) can be converted to finite automata, demonstrating the equivalence between these two formalisms for describing regular languages.

## Objectives:

* Implement a Grammar class that can generate valid strings according to production rules.
* Implement a Finite Automaton class that can validate strings.
* Create a conversion method from Grammar to Finite Automaton.
* Test the implementation by generating strings and validating them with the converted automaton.

## Implementation description

* The **Grammar class** stores the grammar components and implements string generation. The `generate_string()` method starts from the start symbol and repeatedly applies random production rules, building the output string by accumulating terminal symbols until no non-terminals remain.

```python
def generate_string(self):
    word = ""
    current_symbol = self.start_symbol

    while current_symbol in self.non_terminals:
        production = random.choice(self.rules[current_symbol])

        for char in production:
            if char in self.terminals:
                word += char
            if char in self.non_terminals:
                current_symbol = char
                break
        else:
            current_symbol = None
    return word
```

* The **FiniteAutomaton class** validates input strings by simulating state transitions. The `validate()` method processes each character sequentially, transitioning between states according to the transition function, and returns `True` only if the final state after processing the entire string is an accepting state.

```python
def validate(self, input_string):
    current_state = self.initial_state

    for char in input_string:
        if (current_state, char) in self.transitions:
            current_state = self.transitions[(current_state, char)]
        else:
            return False

    return current_state in self.final_states
```

* The **grammar-to-automaton conversion** transforms each non-terminal into a state and each production rule into a transition. Productions ending with a non-terminal lead to that non-terminal's state, while productions ending with a terminal lead to a special final state 'X', effectively converting the grammar's derivation process into state transitions.

```python
def to_finite_automaton(self):
    states = self.non_terminals | {'X'}
    alphabet = self.terminals
    initial_state = self.start_symbol
    final_states = {'X'}
    transitions = {}

    for head, productions in self.rules.items():
        for p in productions:
            char = p[0]
            next_state = p[1] if len(p) > 1 else 'X'
            transitions[(head, char)] = next_state

    return FiniteAutomaton(states, alphabet, transitions, initial_state, final_states)
```

## Conclusions / Screenshots / Results

The implementation successfully demonstrates the equivalence between regular grammars and finite automata. All strings generated by the grammar were correctly validated by the converted finite automaton, confirming the correctness of both the generation algorithm and the conversion method.

Example output:
```
--- 5 RANDOM VALID STRINGS ---
Generated: dab
Generated: dabd
Generated: dabaabcbabd
Generated: dababd
Generated: dabcbabcbcbd

--- VALIDATION ---
String 'dab': Valid? True
String 'dabd': Valid? True
String 'dabaabcbabd': Valid? True
String 'dababd': Valid? True
String 'dabcbabcbcbd': Valid? True
String 'abc': Valid? False
```

The results show that:
- All generated strings start with 'd' (from production S â†’ dA)
- The finite automaton correctly accepts valid strings
- Invalid strings (like "abc") are properly rejected
- The conversion preserves the language defined by the grammar

## References

1. Hopcroft, J. E., Motwani, R., & Ullman, J. D. (2006). *Introduction to Automata Theory, Languages, and Computation*. Pearson.
2. Sipser, M. (2012). *Introduction to the Theory of Computation*. Cengage Learning.